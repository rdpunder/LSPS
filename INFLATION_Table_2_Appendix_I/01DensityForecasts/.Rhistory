load("Data/mYAcc.rda")
load("Data/mYAccOut.rda")
print((head(mYAcc, 28)))
print((head(mYAccOut, 28)))
plot(as.matrix(mYAcc[,2]), type='l')
for(i in 1:length(lHorizon)){
iHorizon = lHorizon[i]
print(iHorizon)
#Load data
load("Data/data.rda")
# RW: Use acc as dependent variable
if(length(grep(model_name, c('rwnorm','rwstd','rwsstd','rwtpnorm'))) > 0){
data[sDep] = mYAcc[,i]
sum(mYAccOut[,i] != tail(mYAcc[,i], nwindows))
dates = data$date
data = data%>%select(-date)%>%as.matrix()
rownames(data) = as.character(dates)
} else {
dates = data$date
data = data%>%select(-date)%>%as.matrix()
rownames(data) = as.character(dates)
vYAcc = mYAcc[,i]
data = cbind(data,vYAcc)
sDepAcc = paste(sDep, as.character(iHorizon), sep="" )
colnames(data)[colnames(data) == "vYAcc"] = sDepAcc
sum(mYAccOut[,i] != tail(mYAcc[,i], nwindows))
}
####### run rolling window ##########
model = rolling_window(model_function,data,nwindows+iHorizon-1,iHorizon, sDep)
# remark about timing: forecast vYPred[k] is the forecast for t=k
mForecast = matrix(data=NA, nrow=nwindows, ncol=4)
mForecast[,1] = model$forecast[1:nwindows]
lines(mForecast[,1], type='l', col=2)
mForecast[,2] = model$forecastSig_1[1:nwindows]
plot(mForecast[,2], type='l')
mForecast[,3] = model$forecastSig_2[1:nwindows]
plot(mForecast[,3], type='l')
# Save
sFileName = paste("mParamsDF/",model_name,"h",as.character(iHorizon),sep = "")
save(mForecast,file = paste(sFileName,".rda",sep = ""))
reticulate::r_to_py(mForecast)$dump(paste(sFileName,".npy",sep = ""))
}
mForecast
print((head(mYAcc, 28)))
lHorizon
mYAcc = matrix(NA, nrow=length(vYMonthly), ncol=length(lHorizon))
for(j in 1:length(lHorizon)){
h = lHorizon[j]
for(i in h:length(vYMonthly)){
mYAcc[i,j] =  12/h * sum(vYMonthly[(i-h+1):i])
}
}
mYAccOut = tail(mYAcc, nwindows)
# Save
sFileName = paste("mParamsDF/",model_name,"h",as.character(iHorizon),sep = "")
save(mYAcc,file = paste("mYAcc.rda",sep = ""))
reticulate::r_to_py(mYAcc)$dump(paste("mYAcc.npy",sep = ""))
save(mYAccOut,file = paste("mYAccOut.rda",sep = ""))
reticulate::r_to_py(mYAccOut)$dump(paste("mYAccOut.npy",sep = ""))
mYAccOut
load("Data/mYAcc.rda")
mYAcc
mYAcc = matrix(NA, nrow=length(vYMonthly), ncol=length(lHorizon))
for(j in 1:length(lHorizon)){
h = lHorizon[j]
for(i in h:length(vYMonthly)){
mYAcc[i,j] =  12/h * sum(vYMonthly[(i-h+1):i])
}
}
mYAccOut = tail(mYAcc, nwindows)
# Save
sFileName = paste("mParamsDF/",model_name,"h",as.character(iHorizon),sep = "")
save(mYAcc,file = paste("mYAcc.rda",sep = ""))
reticulate::r_to_py(mYAcc)$dump(paste("mYAcc.npy",sep = ""))
save(mYAccOut,file = paste("mYAccOut.rda",sep = ""))
reticulate::r_to_py(mYAccOut)$dump(paste("mYAccOut.npy",sep = ""))
mYAcc
load("Data/mYAcc.rda")
load("Data/mYAccOut.rda")
mYAccOut
plot(as.matrix(mYAcc[,2]), type='l')
for(i in 1:length(lHorizon)){
iHorizon = lHorizon[i]
print(iHorizon)
#Load data
load("Data/data.rda")
# RW: Use acc as dependent variable
if(length(grep(model_name, c('rwnorm','rwstd','rwsstd','rwtpnorm'))) > 0){
data[sDep] = mYAcc[,i]
sum(mYAccOut[,i] != tail(mYAcc[,i], nwindows))
dates = data$date
data = data%>%select(-date)%>%as.matrix()
rownames(data) = as.character(dates)
} else {
dates = data$date
data = data%>%select(-date)%>%as.matrix()
rownames(data) = as.character(dates)
vYAcc = mYAcc[,i]
data = cbind(data,vYAcc)
sDepAcc = paste(sDep, as.character(iHorizon), sep="" )
colnames(data)[colnames(data) == "vYAcc"] = sDepAcc
sum(mYAccOut[,i] != tail(mYAcc[,i], nwindows))
}
####### run rolling window ##########
model = rolling_window(model_function,data,nwindows+iHorizon-1,iHorizon, sDep)
# remark about timing: forecast vYPred[k] is the forecast for t=k
mForecast = matrix(data=NA, nrow=nwindows, ncol=4)
mForecast[,1] = model$forecast[1:nwindows]
lines(mForecast[,1], type='l', col=2)
mForecast[,2] = model$forecastSig_1[1:nwindows]
plot(mForecast[,2], type='l')
mForecast[,3] = model$forecastSig_2[1:nwindows]
plot(mForecast[,3], type='l')
# Save
sFileName = paste("mParamsDF/",model_name,"h",as.character(iHorizon),sep = "")
save(mForecast,file = paste(sFileName,".rda",sep = ""))
reticulate::r_to_py(mForecast)$dump(paste(sFileName,".npy",sep = ""))
}
mForecast
### must add package for specific models ###
packages <- c("roll","HDeconometrics","glmnet","randomForest","tidyverse","TTR","rugarch","reticulate","writexl","rje","devtools")
# Install any that are not already installed
install_if_missing <- function(pkg) {
if (!requireNamespace(pkg, quietly = TRUE)) {
install.packages(pkg)
}
}
# Apply the function to each package
sapply(packages, install_if_missing)
library(devtools)
install_github("gabrielrvsc/HDeconometrics") # provided by Medeiros et al. (2021)
library(HDeconometrics)
library(glmnet)
library(randomForest)
library(tidyverse)
library(TTR)
library(rugarch) # estimation and forecasting univariate GARCH models
library(reticulate)
library(writexl)
library(rje) # logit and expit
source("Functions/rolling_window_tpnorm.R")
source("Functions/functions.R")
#####
## The file with the forecasts will be saved with model_name
model_name = "rwtpnorm"
## The function called to run models is model_function, which is a function from functions.R
model_function = runrwtpnorm
#####
# Other parameters
sDep = "CPIAUCSL"
nwindows = 180
lHorizon = c(6,24)
bSaveY=TRUE
#Load data
load("Data/data.rda")
#Transform dependent variable to accumulative yearly
vYMonthly=as.matrix(data[sDep])
# Load acc data
load("Data/mYAcc.rda")
load("Data/mYAccOut.rda")
print((head(mYAcc, 28)))
print((head(mYAccOut, 28)))
plot(as.matrix(mYAcc[,2]), type='l')
for(i in 1:length(lHorizon)){
iHorizon = lHorizon[i]
print(iHorizon)
# RW: Use acc as dependent variable
if(length(grep(model_name, c('rwnorm','rwstd','rwsstd','rwtpnorm'))) > 0){
data[sDep] = mYAcc[,i]
sum(mYAccOut[,i] != tail(mYAcc[,i], nwindows))
dates = data$date
data = data%>%select(-date)%>%as.matrix()
rownames(data) = as.character(dates)
} else {
dates = data$date
data = data%>%select(-date)%>%as.matrix()
rownames(data) = as.character(dates)
vYAcc = mYAcc[,i]
data = cbind(data,vYAcc)
sDepAcc = paste(sDep, as.character(iHorizon), sep="" )
colnames(data)[colnames(data) == "vYAcc"] = sDepAcc
sum(mYAccOut[,i] != tail(mYAcc[,i], nwindows))
}
####### run rolling window ##########
model = rolling_window(model_function,data,nwindows+iHorizon-1,iHorizon, sDep)
# remark about timing: forecast vYPred[k] is the forecast for t=k
mForecast = matrix(data=NA, nrow=nwindows, ncol=4)
mForecast[,1] = model$forecast[1:nwindows]
lines(mForecast[,1], type='l', col=2)
mForecast[,2] = model$forecastSig_1[1:nwindows]
plot(mForecast[,2], type='l')
mForecast[,3] = model$forecastSig_2[1:nwindows]
plot(mForecast[,3], type='l')
# Save
sFileName = paste("mParamsDF/",model_name,"h",as.character(iHorizon),sep = "")
save(mForecast,file = paste(sFileName,".rda",sep = ""))
reticulate::r_to_py(mForecast)$dump(paste(sFileName,".npy",sep = ""))
}
### must add package for specific models ###
packages <- c("roll","HDeconometrics","glmnet","randomForest","tidyverse","TTR","rugarch","reticulate","writexl","rje","devtools")
# Install any that are not already installed
install_if_missing <- function(pkg) {
if (!requireNamespace(pkg, quietly = TRUE)) {
install.packages(pkg)
}
}
# Apply the function to each package
sapply(packages, install_if_missing)
library(devtools)
install_github("gabrielrvsc/HDeconometrics") # provided by Medeiros et al. (2021)
library(HDeconometrics)
library(glmnet)
library(randomForest)
library(tidyverse)
library(TTR)
library(rugarch) # estimation and forecasting univariate GARCH models
library(reticulate)
library(writexl)
library(rje) # logit and expit
source("Functions/rolling_window_tpnorm.R")
source("Functions/functions.R")
#####
## The file with the forecasts will be saved with model_name
model_name = "rwtpnorm"
## The function called to run models is model_function, which is a function from functions.R
model_function = runrwtpnorm
#####
# Other parameters
sDep = "CPIAUCSL"
nwindows = 180
lHorizon = c(6,24)
bSaveY=TRUE
#Load data
load("Data/data.rda")
#Transform dependent variable to accumulative yearly
vYMonthly=as.matrix(data[sDep])
# Load acc data
load("Data/mYAcc.rda")
load("Data/mYAccOut.rda")
print((head(mYAcc, 28)))
print((head(mYAccOut, 28)))
plot(as.matrix(mYAcc[,2]), type='l')
for(i in 1:length(lHorizon)){
iHorizon = lHorizon[i]
print(iHorizon)
#Load data
load("Data/data.rda")
# RW: Use acc as dependent variable
if(length(grep(model_name, c('rwnorm','rwstd','rwsstd','rwtpnorm'))) > 0){
data[sDep] = mYAcc[,i]
sum(mYAccOut[,i] != tail(mYAcc[,i], nwindows))
dates = data$date
data = data%>%select(-date)%>%as.matrix()
rownames(data) = as.character(dates)
} else {
dates = data$date
data = data%>%select(-date)%>%as.matrix()
rownames(data) = as.character(dates)
vYAcc = mYAcc[,i]
data = cbind(data,vYAcc)
sDepAcc = paste(sDep, as.character(iHorizon), sep="" )
colnames(data)[colnames(data) == "vYAcc"] = sDepAcc
sum(mYAccOut[,i] != tail(mYAcc[,i], nwindows))
}
####### run rolling window ##########
model = rolling_window(model_function,data,nwindows+iHorizon-1,iHorizon, sDep)
# remark about timing: forecast vYPred[k] is the forecast for t=k
mForecast = matrix(data=NA, nrow=nwindows, ncol=4)
mForecast[,1] = model$forecast[1:nwindows]
lines(mForecast[,1], type='l', col=2)
mForecast[,2] = model$forecastSig_1[1:nwindows]
plot(mForecast[,2], type='l')
mForecast[,3] = model$forecastSig_2[1:nwindows]
plot(mForecast[,3], type='l')
# Save
sFileName = paste("mParamsDF/",model_name,"h",as.character(iHorizon),sep = "")
save(mForecast,file = paste(sFileName,".rda",sep = ""))
reticulate::r_to_py(mForecast)$dump(paste(sFileName,".npy",sep = ""))
}
mForecast
### must add package for specific models ###
packages <- c("roll","HDeconometrics","glmnet","randomForest","tidyverse","TTR","rugarch","reticulate","writexl","rje","devtools")
# Install any that are not already installed
install_if_missing <- function(pkg) {
if (!requireNamespace(pkg, quietly = TRUE)) {
install.packages(pkg)
}
}
# Apply the function to each package
sapply(packages, install_if_missing)
library(devtools)
install_github("gabrielrvsc/HDeconometrics") # provided by Medeiros et al. (2021)
library(HDeconometrics)
library(glmnet)
library(randomForest)
library(tidyverse)
library(TTR)
library(rugarch) # estimation and forecasting univariate GARCH models
library(reticulate)
library(writexl)
library(rje) # logit and expit
source("Functions/rolling_window_tpnorm.R")
source("Functions/functions.R")
#####
## The file with the forecasts will be saved with model_name
model_name = "rwtpnorm"
## The function called to run models is model_function, which is a function from functions.R
model_function = runrwtpnorm
#####
# Other parameters
sDep = "CPIAUCSL"
nwindows = 180
lHorizon = c(6,24)
#Load data
load("Data/data.rda")
#Transform dependent variable to accumulative yearly
vYMonthly=as.matrix(data[sDep])
mYAcc = matrix(NA, nrow=length(vYMonthly), ncol=length(lHorizon))
for(j in 1:length(lHorizon)){
h = lHorizon[j]
for(i in h:length(vYMonthly)){
mYAcc[i,j] =  12/h * sum(vYMonthly[(i-h+1):i])
}
}
mYAccOut = tail(mYAcc, nwindows)
# Save
save(mYAcc,file = paste("Data/mYAcc.rda",sep = ""))
reticulate::r_to_py(mYAcc)$dump(paste("Data/mYAcc.npy",sep = ""))
save(mYAccOut,file = paste("Data/mYAccOut.rda",sep = ""))
reticulate::r_to_py(mYAccOut)$dump(paste("Data/mYAccOut.npy",sep = ""))
setwd("~/Library/CloudStorage/Dropbox/DDLV/LSPS/Revision/Python/EmpiricalApplications/Inflation/01DensityForecasts")
### must add package for specific models ###
packages <- c("roll","HDeconometrics","glmnet","randomForest","tidyverse","TTR","rugarch","reticulate","writexl","rje","devtools")
# Install any that are not already installed
install_if_missing <- function(pkg) {
if (!requireNamespace(pkg, quietly = TRUE)) {
install.packages(pkg)
}
}
# Apply the function to each package
sapply(packages, install_if_missing)
library(devtools)
install_github("gabrielrvsc/HDeconometrics") # provided by Medeiros et al. (2021)
library(HDeconometrics)
library(glmnet)
library(randomForest)
library(tidyverse)
library(TTR)
library(rugarch) # estimation and forecasting univariate GARCH models
library(reticulate)
library(writexl)
library(rje) # logit and expit
source("Functions/rolling_window_tpnorm.R")
source("Functions/functions.R")
#####
## The file with the forecasts will be saved with model_name
model_name = "rwtpnorm"
## The function called to run models is model_function, which is a function from functions.R
model_function = runrwtpnorm
#####
# Other parameters
sDep = "CPIAUCSL"
nwindows = 180
lHorizon = c(6,24)
#Load data
load("Data/data.rda")
#Transform dependent variable to accumulative yearly
vYMonthly=as.matrix(data[sDep])
mYAcc = matrix(NA, nrow=length(vYMonthly), ncol=length(lHorizon))
for(j in 1:length(lHorizon)){
h = lHorizon[j]
for(i in h:length(vYMonthly)){
mYAcc[i,j] =  12/h * sum(vYMonthly[(i-h+1):i])
}
}
mYAccOut = tail(mYAcc, nwindows)
# Save
save(mYAcc,file = paste("Data/mYAcc.rda",sep = ""))
reticulate::r_to_py(mYAcc)$dump(paste("Data/mYAcc.npy",sep = ""))
save(mYAccOut,file = paste("Data/mYAccOut.rda",sep = ""))
reticulate::r_to_py(mYAccOut)$dump(paste("Data/mYAccOut.npy",sep = ""))
### must add package for specific models ###
packages <- c("roll","HDeconometrics","glmnet","randomForest","tidyverse","TTR","rugarch","reticulate","writexl","rje","devtools")
# Install any that are not already installed
install_if_missing <- function(pkg) {
if (!requireNamespace(pkg, quietly = TRUE)) {
install.packages(pkg)
}
}
# Apply the function to each package
sapply(packages, install_if_missing)
library(devtools)
install_github("gabrielrvsc/HDeconometrics") # provided by Medeiros et al. (2021)
library(HDeconometrics)
library(glmnet)
library(randomForest)
library(tidyverse)
library(TTR)
library(rugarch) # estimation and forecasting univariate GARCH models
library(reticulate)
library(writexl)
library(rje) # logit and expit
source("Functions/rolling_window_tpnorm.R")
source("Functions/functions.R")
#####
## The file with the forecasts will be saved with model_name
model_name = "rwtpnorm"
## The function called to run models is model_function, which is a function from functions.R
model_function = runrwtpnorm
#####
# Other parameters
sDep = "CPIAUCSL"
nwindows = 180
lHorizon = c(6,24)
#Load data
load("Data/data.rda")
#Transform dependent variable to accumulative yearly
vYMonthly=as.matrix(data[sDep])
mYAcc = matrix(NA, nrow=length(vYMonthly), ncol=length(lHorizon))
for(j in 1:length(lHorizon)){
h = lHorizon[j]
for(i in h:length(vYMonthly)){
mYAcc[i,j] =  12/h * sum(vYMonthly[(i-h+1):i])
}
}
mYAccOut = tail(mYAcc, nwindows)
# Save
save(mYAcc,file = paste("Data/mYAcc.rda",sep = ""))
reticulate::r_to_py(mYAcc)$dump(paste("Data/mYAcc.npy",sep = ""))
save(mYAccOut,file = paste("Data/mYAccOut.rda",sep = ""))
reticulate::r_to_py(mYAccOut)$dump(paste("Data/mYAccOut.npy",sep = ""))
### must add package for specific models ###
packages <- c("roll","HDeconometrics","glmnet","randomForest","tidyverse","TTR","rugarch","reticulate","writexl","rje","devtools")
# Install any that are not already installed
install_if_missing <- function(pkg) {
if (!requireNamespace(pkg, quietly = TRUE)) {
install.packages(pkg)
}
}
# Apply the function to each package
sapply(packages, install_if_missing)
library(devtools)
install_github("gabrielrvsc/HDeconometrics") # provided by Medeiros et al. (2021)
library(HDeconometrics)
library(glmnet)
library(randomForest)
library(tidyverse)
library(TTR)
library(rugarch) # estimation and forecasting univariate GARCH models
library(reticulate)
library(writexl)
library(rje) # logit and expit
source("Functions/rolling_window_tpnorm.R")
source("Functions/functions.R")
#####
## The file with the forecasts will be saved with model_name
model_name = "rwtpnorm"
## The function called to run models is model_function, which is a function from functions.R
model_function = runrwtpnorm
#####
# Other parameters
sDep = "CPIAUCSL"
nwindows = 180
lHorizon = c(6,24)
#Load data
load("Data/data.rda")
#Transform dependent variable to accumulative yearly
vYMonthly=as.matrix(data[sDep])
# Load acc data
load("Data/mYAcc.rda")
load("Data/mYAccOut.rda")
print((head(mYAcc, 28)))
print((head(mYAccOut, 28)))
plot(as.matrix(mYAcc[,2]), type='l')
for(i in 1:length(lHorizon)){
iHorizon = lHorizon[i]
print(iHorizon)
#Load data
load("Data/data.rda")
# RW: Use acc as dependent variable
if(length(grep(model_name, c('rwnorm','rwstd','rwsstd','rwtpnorm'))) > 0){
data[sDep] = mYAcc[,i]
sum(mYAccOut[,i] != tail(mYAcc[,i], nwindows))
dates = data$date
data = data%>%select(-date)%>%as.matrix()
rownames(data) = as.character(dates)
} else {
dates = data$date
data = data%>%select(-date)%>%as.matrix()
rownames(data) = as.character(dates)
vYAcc = mYAcc[,i]
data = cbind(data,vYAcc)
sDepAcc = paste(sDep, as.character(iHorizon), sep="" )
colnames(data)[colnames(data) == "vYAcc"] = sDepAcc
sum(mYAccOut[,i] != tail(mYAcc[,i], nwindows))
}
####### run rolling window ##########
model = rolling_window(model_function,data,nwindows+iHorizon-1,iHorizon, sDep)
# remark about timing: forecast vYPred[k] is the forecast for t=k
mForecast = matrix(data=NA, nrow=nwindows, ncol=4)
mForecast[,1] = model$forecast[1:nwindows]
lines(mForecast[,1], type='l', col=2)
mForecast[,2] = model$forecastSig_1[1:nwindows]
plot(mForecast[,2], type='l')
mForecast[,3] = model$forecastSig_2[1:nwindows]
plot(mForecast[,3], type='l')
# Save
sFileName = paste("mParamsDF/",model_name,"h",as.character(iHorizon),sep = "")
save(mForecast,file = paste(sFileName,".rda",sep = ""))
reticulate::r_to_py(mForecast)$dump(paste(sFileName,".npy",sep = ""))
}
mForecast
