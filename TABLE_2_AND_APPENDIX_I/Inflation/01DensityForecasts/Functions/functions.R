# Fast replicate for new method
SampleVar = function(vRes, iHorizon, sDistr){
  return(c(var(vRes)))
}

#### Data Preperation ####
# Note: Medeiros et al. propose to use acc-acc for RW 

dataprep_rw = function(ind,df,variable,horizon,add_dummy = TRUE, univar = FALSE, factonly = FALSE, nofact = FALSE)
{
  df=na.omit(df[ind,]) # omit na generated by selecting accumulated dependent variable
  y=df[,variable]
  
  if(nofact==TRUE){
    if(univar==FALSE){
      x=df
    }else{
      x = as.matrix(df[,variable])
    }
  }else{
    if(univar==FALSE){
      factors=princomp(scale(df))$scores[,1:4]
      if(factonly == TRUE){
        x = cbind(df[,variable],factors)
      }else{
        x=cbind(df,factors)
      }
    }else{
      x = as.matrix(df[,variable])
    }
  }
  
  X=embed(as.matrix(x),4)
  Xin=X[-c((nrow(X)-horizon+1):nrow(X)),]
  Xout=X[nrow(X),]
  Xout=t(as.vector(Xout))
  yin=tail(y,nrow(Xin))
  
  if("2008-11-01" %in% names(yin)){
    
    dummy=rep(0,length(yin))
    intervention=which(names(yin)=="2008-11-01")
    dummy[intervention]=1
    if(add_dummy == TRUE){
      Xin=cbind(Xin,dummy)
      Xout=cbind(Xout,0)
    }
    
  }else{
    dummy = rep(0,length(yin))
    if(add_dummy == TRUE){
      Xin=cbind(Xin,dummy)
      Xout=cbind(Xout,0)
    }
  }
  
  return(list(dummy = dummy, Xin = Xin, Xout = Xout, yin = yin))
  
}

#### Data Preperation ####
dataprep = function(ind,df,variable,horizon,add_dummy = TRUE, univar = FALSE, factonly = FALSE, nofact = FALSE)
{
  # input full dataframe, including both one-month and accumulated inflation
  df=na.omit(df[ind,]) # omit na generated by selecting accumulated dependent variable
  
  # select dependent variable
  sDepAcc = paste(variable, as.character(horizon), sep="" )
  vYAcc = df[,sDepAcc]
  
  # remove dependent variable from dataframe
  
  dfNonAcc = df[, -which(colnames(df) == sDepAcc)]
  
  
  if(nofact==TRUE){
    if(univar==FALSE){
      # whole dataframe - except accumlated dependent variable is used
      x=dfNonAcc
    }else{
      # only one-month inflation and lags are used
      x = as.matrix(dfNonAcc[,variable])
    }
  }else{
    
    if(univar==FALSE){
      factors=princomp(scale(dfNonAcc))$scores[,1:4]
      if(factonly == TRUE){
        x = cbind(dfNonAcc[,variable],factors)
      }else{
        x=cbind(dfNonAcc,factors)
      }
    }else{
      x = as.matrix(dfNonAcc[,variable])
    }
  }
  
  X=embed(as.matrix(x),4)
  Xin=X[-c((nrow(X)-horizon+1):nrow(X)),]
  Xout=X[nrow(X),]
  Xout=t(as.vector(Xout))
  yin=tail(vYAcc,nrow(Xin))
  
  if("2008-11-01" %in% names(yin)){
    
    dummy=rep(0,length(yin))
    intervention=which(names(yin)=="2008-11-01")
    dummy[intervention]=1
    if(add_dummy == TRUE){
      Xin=cbind(Xin,dummy)
      Xout=cbind(Xout,0)
    }
    
  }else{
    dummy = rep(0,length(yin))
    if(add_dummy == TRUE){
      Xin=cbind(Xin,dummy)
      Xout=cbind(Xout,0)
    }
  }
  
  return(list(dummy = dummy, Xin = Xin, Xout = Xout, yin = yin))
  
}

###########################################################
### QML

## Two-piece normal [BoE]

# Link function Nu [Nu -> NuTr]
TPNormalParamsLink = function(vParams){
  vParamsTr = log(vParams)
  return(vParamsTr)
}

# Inverse link function Nu [Nu -> NuTr]
TPNormalParamsLinkInverse = function(vParamsTr){
  vParams = exp(vParamsTr)
  return(vParams)
}

# Average negative loglikelihood TPNormal 
AvgNLnLStandTPNormal = function(vParams, vY){
  dSig_1 = vParams[1] 
  dSig_2 = vParams[2]
  vLL = matrix(NA,nrow=length(vY))
  vLL[vY<=0] = -1/2 * log(pi/2) - log(dSig_1 + dSig_2) - 1/2 * (vY[vY<=0]/dSig_1)^2 # before: log(2pi), doesn't matter for estimation
  vLL[vY>0] = -1/2 * log(pi/2) - log(dSig_1 + dSig_2) - 1/2 * (vY[vY>0]/dSig_2)^2
  dALL= mean(vLL)
  return(-dALL)
}

# Wrapper average negative loglikelihood standardised TPNormal
AvgNLnLStandTrTPNormal = function(vParamsTr, vY){
  return(AvgNLnLStandTPNormal(TPNormalParamsLinkInverse(vParamsTr), vY))
}

# QMLE for SStd
TPNormalML=function(vY, vParamsStart){
  vParamsStartTr = TPNormalParamsLink(vParamsStart) 
  vParamsHatTr = optim(vParamsStartTr, AvgNLnLStandTrTPNormal, method="L-BFGS-B", vY=vY)$par
  return(TPNormalParamsLinkInverse(vParamsHatTr))
}

###########################################################
####################### RW models #########################    
###########################################################

runrwtpnorm = function(ind,df,variable,horizon, type = "fixed"){
  # ind is a vector of length window size
  prep_data = dataprep_rw(ind,df,variable,horizon, univar = TRUE, add_dummy = FALSE)
  Xin = prep_data$Xin
  yin = prep_data$yin
  Xout = prep_data$Xout
  forecast = Xout[,1]

  # calculate residuals
  vRes = yin - Xin[,1]
  vParamsHat=TPNormalML(vRes, vParamsStart=c(1,1))
  return(list(forecast=forecast, forecastSig_1 = vParamsHat[1], forecastSig_2 = vParamsHat[2]))
  
}

###########################################################
########################## AR #############################    
###########################################################

runartpnorm=function(ind,df,variable,horizon, type = "fixed"){
  # ind is a vector of length window size
  prep_data = dataprep(ind,df,variable,horizon, univar = TRUE, add_dummy = FALSE)
  Xin = prep_data$Xin
  yin = prep_data$yin
  Xout = prep_data$Xout
  dummy = prep_data$dummy
  if(type=="fixed"){
    modelest=lm(yin~Xin+dummy)
    best = ncol(Xin)
  }
  if(type=="bic"){
    bb=Inf
    best = 1
    for(i in seq(1,ncol(Xin),1)){
      m=lm(yin~Xin[,1:i]+dummy)
      crit=BIC(m)
      if(crit<bb){
        bb=crit
        modelest=m
        best = i
      }
    }
  }
  coef=coef(modelest)
  coef[is.na(coef)] = 0
  forecast=c(1,Xout[,1:best],0)%*%coef
  
  # residuals
  vRes=residuals(modelest)
  vParamsHat=TPNormalML(vRes, vParamsStart=c(1,1))
  return(list(forecast=forecast, forecastSig_1 = vParamsHat[1], forecastSig_2 = vParamsHat[2]))
}

###########################################################
########################### RF ############################    
###########################################################

runrf=function(ind,df,variable,horizon){
  prep_data = dataprep(ind,df,variable,horizon)
  Xin = prep_data$Xin
  yin = prep_data$yin
  Xout = prep_data$Xout
  
  modelest=randomForest::randomForest(Xin,yin, importance = TRUE)
  forecast=predict(modelest,Xout)
  
  ## outputs
  importance = randomForest::importance(modelest)
  outputs = list(importance = importance)
  
  return(list(forecast=forecast, outputs = outputs))
}

runrftpnorm=function(ind,df,variable,horizon){
  prep_data = dataprep(ind,df,variable,horizon)
  Xin = prep_data$Xin
  yin = prep_data$yin
  Xout = prep_data$Xout
  
  modelest=randomForest::randomForest(Xin,yin, importance = TRUE)
  forecast=predict(modelest,Xout)
  
  ## outputs
  importance = randomForest::importance(modelest)
  outputs = list(importance = importance)
  
  #  residuals
  vRes= yin - modelest[["predicted"]]
  vParamsHat=TPNormalML(vRes, vParamsStart=c(1,1))
  return(list(forecast=forecast, forecastSig_1 = vParamsHat[1], forecastSig_2 = vParamsHat[2]))
}

###########################################################
######################## LASSO  ###########################    
###########################################################

runlassotpnorm=function(ind,df,variable,horizon, alpha = 1, alpha2 = 1, adaptive = FALSE){
  
  prep_data = dataprep(ind,df,variable,horizon)
  Xin = prep_data$Xin
  yin = prep_data$yin
  Xout = prep_data$Xout
  
  modelest = ic.glmnet(Xin,yin,alpha = alpha)
  if(adaptive==TRUE){
    classo = coef(modelest)
    penalty = (abs(classo[-1])+1/sqrt(length(yin)))^(-1)
    modelest = ic.glmnet(Xin,yin, penalty.factor = penalty, alpha = alpha2)
  }
  
  forecast=predict(modelest,Xout)
  
  ### outputs ###
  coeflvl=coef(modelest)[-1]
  coefpar=coeflvl*apply(Xin,2,sd)
  lambda=modelest$lambda
  outputs=list(coeflvl=coeflvl,coefpar=coefpar,lambda=lambda)
  
  #  residuals
  vRes=  modelest$residuals
  dForecastSig2 = SampleVar(vRes, horizon, 'norm') #QML
  vRes=residuals(modelest)
  
  vParamsHat=TPNormalML(vRes, vParamsStart=c(1,1))
  return(list(forecast=forecast, forecastSig_1 = vParamsHat[1], forecastSig_2 = vParamsHat[2]))
  }

###########################################################
###################### Bagging ############################    
###########################################################

runbaggingtpnorm=function(ind,df,variable,horizon){
  prep_data = dataprep(ind,df,variable,horizon)
  Xin = prep_data$Xin
  yin = prep_data$yin
  Xout = prep_data$Xout
  
  modelest=bagging(Xin,yin,R=100,l=5,pre.testing = "group-joint")
  forecast = predict(modelest,Xout)
  
  ## outputs
  nselect=modelest$coefficients
  nselect[nselect!=0]=1
  nselect[is.na(nselect)]=0
  nselect=colSums(nselect)
  
  outputs = list(nselect = nselect)
  
  # residuals
  vRes=modelest$residuals
  dForecastSig2 = SampleVar(vRes, horizon, 'norm') #QML
  vRes=residuals(modelest)
  vParamsHat=TPNormalML(vRes, vParamsStart=c(1,1))
  return(list(forecast=forecast, forecastSig_1 = vParamsHat[1], forecastSig_2 = vParamsHat[2]))
}

###########################################################
################## Subsetregression #######################    
###########################################################

runcsrtpnorm=function(ind,df,variable,horizon){
  prep_data = dataprep(ind,df,variable,horizon)
  Xin = prep_data$Xin
  yin = prep_data$yin
  Xout = prep_data$Xout
  
  indice = which(colnames(df)==variable)
  f.seq=seq(indice,ncol(Xin)-1,ncol(df)+4)
  modelest=csr(Xin,yin,fixed.controls =c(f.seq,ncol(Xin)))
  forecast = predict(modelest,Xout)
  
  ## outputs
  nselect=modelest$coefficients
  nselect[nselect!=0]=1
  nselect[is.na(nselect)]=0
  nselect=colSums(nselect)
  
  outputs = list(nselect = nselect)
  
  # residuals
  vRes = modelest$residuals
  
  vParamsHat=TPNormalML(vRes, vParamsStart=c(1,1))
  return(list(forecast=forecast, forecastSig_1 = vParamsHat[1], forecastSig_2 = vParamsHat[2]))
  }

